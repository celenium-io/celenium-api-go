/*
Celenium API

Celenium API is a powerful tool to access all blockchain data that is processed and indexed by our proprietary indexer. With Celenium API you can retrieve all historical data, off-chain data, blobs and statistics through our REST API. Celenium API indexer are open source, which allows you to not depend on third-party services. You can clone, build and run them independently, giving you full control over all components. If you have any questions or feature requests, please feel free to contact us. We appreciate your feedback!

API version: 1.0
Contact: celenium@pklabs.me
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package celenium

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ProposalAPIService ProposalAPI service
type ProposalAPIService service

type ApiListProposalRequest struct {
	ctx context.Context
	ApiService *ProposalAPIService
	limit *int32
	offset *int32
	sort *string
	proposer *string
	status *string
	type_ *string
}

// Count of requested entities
func (r ApiListProposalRequest) Limit(limit int32) ApiListProposalRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiListProposalRequest) Offset(offset int32) ApiListProposalRequest {
	r.offset = &offset
	return r
}

// Sort order. Default: desc
func (r ApiListProposalRequest) Sort(sort string) ApiListProposalRequest {
	r.sort = &sort
	return r
}

// Proposer celestia address
func (r ApiListProposalRequest) Proposer(proposer string) ApiListProposalRequest {
	r.proposer = &proposer
	return r
}

// Comma-separated proposal status list
func (r ApiListProposalRequest) Status(status string) ApiListProposalRequest {
	r.status = &status
	return r
}

// Comma-separated proposal type list
func (r ApiListProposalRequest) Type_(type_ string) ApiListProposalRequest {
	r.type_ = &type_
	return r
}

func (r ApiListProposalRequest) Execute() ([]ResponsesProposal, *http.Response, error) {
	return r.ApiService.ListProposalExecute(r)
}

/*
ListProposal List proposal info

List proposal info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListProposalRequest
*/
func (a *ProposalAPIService) ListProposal(ctx context.Context) ApiListProposalRequest {
	return ApiListProposalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ResponsesProposal
func (a *ProposalAPIService) ListProposalExecute(r ApiListProposalRequest) ([]ResponsesProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResponsesProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProposalAPIService.ListProposal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proposal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	}
	if r.proposer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proposer", r.proposer, "", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HandlerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HandlerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Celenium API

Celenium API is a powerful tool to access all blockchain data that is processed and indexed by our proprietary indexer. With Celenium API you can retrieve all historical data, off-chain data, blobs and statistics through our REST API. Celenium API indexer are open source, which allows you to not depend on third-party services. You can clone, build and run them independently, giving you full control over all components. If you have any questions or feature requests, please feel free to contact us. We appreciate your feedback!

API version: 1.0
Contact: celenium@pklabs.me
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package celenium

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SignalAPIService SignalAPI service
type SignalAPIService service

type ApiListSignalRequest struct {
	ctx context.Context
	ApiService *SignalAPIService
	version *int32
	validatorId *int32
	txHash *string
	limit *int32
	offset *int32
	from *int32
	to *int32
	sort *string
}

// Version
func (r ApiListSignalRequest) Version(version int32) ApiListSignalRequest {
	r.version = &version
	return r
}

// Validator internal id
func (r ApiListSignalRequest) ValidatorId(validatorId int32) ApiListSignalRequest {
	r.validatorId = &validatorId
	return r
}

// Transaction hash
func (r ApiListSignalRequest) TxHash(txHash string) ApiListSignalRequest {
	r.txHash = &txHash
	return r
}

// Count of requested entities
func (r ApiListSignalRequest) Limit(limit int32) ApiListSignalRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiListSignalRequest) Offset(offset int32) ApiListSignalRequest {
	r.offset = &offset
	return r
}

// Time from in unix timestamp
func (r ApiListSignalRequest) From(from int32) ApiListSignalRequest {
	r.from = &from
	return r
}

// Time to in unix timestamp
func (r ApiListSignalRequest) To(to int32) ApiListSignalRequest {
	r.to = &to
	return r
}

// Sort order. Default: desc
func (r ApiListSignalRequest) Sort(sort string) ApiListSignalRequest {
	r.sort = &sort
	return r
}

func (r ApiListSignalRequest) Execute() ([]ResponsesSignalVersion, *http.Response, error) {
	return r.ApiService.ListSignalExecute(r)
}

/*
ListSignal List signals

List signals

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSignalRequest
*/
func (a *SignalAPIService) ListSignal(ctx context.Context) ApiListSignalRequest {
	return ApiListSignalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ResponsesSignalVersion
func (a *SignalAPIService) ListSignalExecute(r ApiListSignalRequest) ([]ResponsesSignalVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResponsesSignalVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIService.ListSignal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "", "")
	}
	if r.validatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validator_id", r.validatorId, "", "")
	}
	if r.txHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_hash", r.txHash, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HandlerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HandlerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUpgradesRequest struct {
	ctx context.Context
	ApiService *SignalAPIService
	height *int32
	txHash *string
	signer *string
	limit *int32
	offset *int32
	sort *string
}

// Number of block
func (r ApiListUpgradesRequest) Height(height int32) ApiListUpgradesRequest {
	r.height = &height
	return r
}

// Transaction hash
func (r ApiListUpgradesRequest) TxHash(txHash string) ApiListUpgradesRequest {
	r.txHash = &txHash
	return r
}

// Signer address
func (r ApiListUpgradesRequest) Signer(signer string) ApiListUpgradesRequest {
	r.signer = &signer
	return r
}

// Count of requested entities
func (r ApiListUpgradesRequest) Limit(limit int32) ApiListUpgradesRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiListUpgradesRequest) Offset(offset int32) ApiListUpgradesRequest {
	r.offset = &offset
	return r
}

// Sort order. Default: desc
func (r ApiListUpgradesRequest) Sort(sort string) ApiListUpgradesRequest {
	r.sort = &sort
	return r
}

func (r ApiListUpgradesRequest) Execute() ([]ResponsesUpgrade, *http.Response, error) {
	return r.ApiService.ListUpgradesExecute(r)
}

/*
ListUpgrades List upgrades

List upgrades

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListUpgradesRequest
*/
func (a *SignalAPIService) ListUpgrades(ctx context.Context) ApiListUpgradesRequest {
	return ApiListUpgradesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ResponsesUpgrade
func (a *SignalAPIService) ListUpgradesExecute(r ApiListUpgradesRequest) ([]ResponsesUpgrade, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResponsesUpgrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIService.ListUpgrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/signal/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "", "")
	}
	if r.txHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_hash", r.txHash, "", "")
	}
	if r.signer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signer", r.signer, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HandlerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v HandlerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
